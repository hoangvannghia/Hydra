//
//  SignalProtocol.swift
//  Hydra-iOS
//
//  Created by danielemargutti on 07/01/2018.
//  Copyright Â© 2018 Hydra. All rights reserved.
//

import Foundation

/// This is the protocol implemented by signal, a sequence of events.
public protocol SignalProtocol {
	
	/// The type of values generated by the signal.
	associatedtype V
	
	/// The type of error can terminate the signal.
	associatedtype E: Swift.Error
	
	/// Register a new observer to receive events from the signal stream.
	///
	/// - Parameter observer: observer callback.
	/// - Returns: Disposable instance used to cancel registration of the observer.
	func subscribe(_ observer: @escaping Observer<V,E>) -> DisposableProtocol
}


extension SignalProtocol {
	
	/// Observe another observer. This is valid only for signal with the same value/error types.
	///
	/// - Parameter observer: observer to observe
	/// - Returns: signal
	public func observe<O: ObserverProtocol>(_ observer: O) -> DisposableProtocol where O.V == V, O.E == E {
		return subscribe(observer.dispatch)
	}
	
	/// Run the producer's code of the signal into specified context (by default a signal is
	/// executed in the same thread of the caller).
	///
	/// - Parameter context: context used to run producer's code
	/// - Returns: signal
	public func run(in context: Context) -> Signal<V,E> {
		return Signal { observer in
			let serialDisposable = SafeDisposable()
			context.queue.async {
				if !serialDisposable.isDisposed {
					serialDisposable.linkedDisposable = self.subscribe(observer.dispatch)
				}
			}
			return serialDisposable
		}
	}
	
	/// This is a shortcut to receive only transmitted values from the signal ignoring
	/// errors and complete events.
	///
	/// - Parameter observer: observer callback
	/// - Returns: Disposable for event's observer
	public func onValue(_ observer: @escaping (V) -> Void) -> DisposableProtocol {
		return self.subscribe { event in
			if case .next(let element) = event {
				observer(element)
			}
		}
	}
	
	/// This is a shortcut to receive only transmitted errors from the signal
	/// ignoring values and complete events.
	///
	/// - Parameter observer: observer callback
	/// - Returns: Disposable for event's observer
	public func onFail(_ observer: @escaping (E) -> Void) -> DisposableProtocol {
		return self.subscribe { event in
			if case .failed(let e) = event {
				observer(e)
			}
		}
	}
	
	
	/// This s a shortcut to receive only completion event from the signal.
	///
	/// - Parameter observer: observer callback
	/// - Returns: Disposable for event's observer
	public func onComplete(_ observer: @escaping () -> Void) -> DisposableProtocol {
		return self.subscribe {
			if case .completed = $0 {
				observer()
			}
		}
	}
}


